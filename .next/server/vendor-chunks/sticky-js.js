/*
 * ATTENTION: An "eval-source-map" devtool has been used.
 * This devtool is neither made for production nor for readable output files.
 * It uses "eval()" calls to create a separate source file with attached SourceMaps in the browser devtools.
 * If you are trying to read the output file, select a different devtool (https://webpack.js.org/configuration/devtool/)
 * or disable the default devtool with "devtool: false".
 * If you are looking for production-ready output files, see mode: "production" (https://webpack.js.org/configuration/mode/).
 */
exports.id = "vendor-chunks/sticky-js";
exports.ids = ["vendor-chunks/sticky-js"];
exports.modules = {

/***/ "(ssr)/./node_modules/sticky-js/dist/sticky.compile.js":
/*!*******************************************************!*\
  !*** ./node_modules/sticky-js/dist/sticky.compile.js ***!
  \*******************************************************/
/***/ (function(module) {

eval("function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError(\"Cannot call a class as a function\"); } }\n\nfunction _defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if (\"value\" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } }\n\nfunction _createClass(Constructor, protoProps, staticProps) { if (protoProps) _defineProperties(Constructor.prototype, protoProps); if (staticProps) _defineProperties(Constructor, staticProps); return Constructor; }\n\n/**\n * Sticky.js\n * Library for sticky elements written in vanilla javascript. With this library you can easily set sticky elements on your website. It's also responsive.\n *\n * @version 1.3.0\n * @author Rafal Galus <biuro@rafalgalus.pl>\n * @website https://rgalus.github.io/sticky-js/\n * @repo https://github.com/rgalus/sticky-js\n * @license https://github.com/rgalus/sticky-js/blob/master/LICENSE\n */\nvar Sticky = /*#__PURE__*/function () {\n  /**\n   * Sticky instance constructor\n   * @constructor\n   * @param {string} selector - Selector which we can find elements\n   * @param {string} options - Global options for sticky elements (could be overwritten by data-{option}=\"\" attributes)\n   */\n  function Sticky() {\n    var selector = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : '';\n    var options = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {};\n\n    _classCallCheck(this, Sticky);\n\n    this.selector = selector;\n    this.elements = [];\n    this.version = '1.3.0';\n    this.vp = this.getViewportSize();\n    this.body = document.querySelector('body');\n    this.options = {\n      wrap: options.wrap || false,\n      wrapWith: options.wrapWith || '<span></span>',\n      marginTop: options.marginTop || 0,\n      marginBottom: options.marginBottom || 0,\n      stickyFor: options.stickyFor || 0,\n      stickyClass: options.stickyClass || null,\n      stickyContainer: options.stickyContainer || 'body'\n    };\n    this.updateScrollTopPosition = this.updateScrollTopPosition.bind(this);\n    this.updateScrollTopPosition();\n    window.addEventListener('load', this.updateScrollTopPosition);\n    window.addEventListener('scroll', this.updateScrollTopPosition);\n    this.run();\n  }\n  /**\n   * Function that waits for page to be fully loaded and then renders & activates every sticky element found with specified selector\n   * @function\n   */\n\n\n  _createClass(Sticky, [{\n    key: \"run\",\n    value: function run() {\n      var _this = this;\n\n      // wait for page to be fully loaded\n      var pageLoaded = setInterval(function () {\n        if (document.readyState === 'complete') {\n          clearInterval(pageLoaded);\n          var elements = document.querySelectorAll(_this.selector);\n\n          _this.forEach(elements, function (element) {\n            return _this.renderElement(element);\n          });\n        }\n      }, 10);\n    }\n    /**\n     * Function that assign needed variables for sticky element, that are used in future for calculations and other\n     * @function\n     * @param {node} element - Element to be rendered\n     */\n\n  }, {\n    key: \"renderElement\",\n    value: function renderElement(element) {\n      var _this2 = this;\n\n      // create container for variables needed in future\n      element.sticky = {}; // set default variables\n\n      element.sticky.active = false;\n      element.sticky.marginTop = parseInt(element.getAttribute('data-margin-top')) || this.options.marginTop;\n      element.sticky.marginBottom = parseInt(element.getAttribute('data-margin-bottom')) || this.options.marginBottom;\n      element.sticky.stickyFor = parseInt(element.getAttribute('data-sticky-for')) || this.options.stickyFor;\n      element.sticky.stickyClass = element.getAttribute('data-sticky-class') || this.options.stickyClass;\n      element.sticky.wrap = element.hasAttribute('data-sticky-wrap') ? true : this.options.wrap; // @todo attribute for stickyContainer\n      // element.sticky.stickyContainer = element.getAttribute('data-sticky-container') || this.options.stickyContainer;\n\n      element.sticky.stickyContainer = this.options.stickyContainer;\n      element.sticky.container = this.getStickyContainer(element);\n      element.sticky.container.rect = this.getRectangle(element.sticky.container);\n      element.sticky.rect = this.getRectangle(element); // fix when element is image that has not yet loaded and width, height = 0\n\n      if (element.tagName.toLowerCase() === 'img') {\n        element.onload = function () {\n          return element.sticky.rect = _this2.getRectangle(element);\n        };\n      }\n\n      if (element.sticky.wrap) {\n        this.wrapElement(element);\n      } // activate rendered element\n\n\n      this.activate(element);\n    }\n    /**\n     * Wraps element into placeholder element\n     * @function\n     * @param {node} element - Element to be wrapped\n     */\n\n  }, {\n    key: \"wrapElement\",\n    value: function wrapElement(element) {\n      element.insertAdjacentHTML('beforebegin', element.getAttribute('data-sticky-wrapWith') || this.options.wrapWith);\n      element.previousSibling.appendChild(element);\n    }\n    /**\n     * Function that activates element when specified conditions are met and then initalise events\n     * @function\n     * @param {node} element - Element to be activated\n     */\n\n  }, {\n    key: \"activate\",\n    value: function activate(element) {\n      if (element.sticky.rect.top + element.sticky.rect.height < element.sticky.container.rect.top + element.sticky.container.rect.height && element.sticky.stickyFor < this.vp.width && !element.sticky.active) {\n        element.sticky.active = true;\n      }\n\n      if (this.elements.indexOf(element) < 0) {\n        this.elements.push(element);\n      }\n\n      if (!element.sticky.resizeEvent) {\n        this.initResizeEvents(element);\n        element.sticky.resizeEvent = true;\n      }\n\n      if (!element.sticky.scrollEvent) {\n        this.initScrollEvents(element);\n        element.sticky.scrollEvent = true;\n      }\n\n      this.setPosition(element);\n    }\n    /**\n     * Function which is adding onResizeEvents to window listener and assigns function to element as resizeListener\n     * @function\n     * @param {node} element - Element for which resize events are initialised\n     */\n\n  }, {\n    key: \"initResizeEvents\",\n    value: function initResizeEvents(element) {\n      var _this3 = this;\n\n      element.sticky.resizeListener = function () {\n        return _this3.onResizeEvents(element);\n      };\n\n      window.addEventListener('resize', element.sticky.resizeListener);\n    }\n    /**\n     * Removes element listener from resize event\n     * @function\n     * @param {node} element - Element from which listener is deleted\n     */\n\n  }, {\n    key: \"destroyResizeEvents\",\n    value: function destroyResizeEvents(element) {\n      window.removeEventListener('resize', element.sticky.resizeListener);\n    }\n    /**\n     * Function which is fired when user resize window. It checks if element should be activated or deactivated and then run setPosition function\n     * @function\n     * @param {node} element - Element for which event function is fired\n     */\n\n  }, {\n    key: \"onResizeEvents\",\n    value: function onResizeEvents(element) {\n      this.vp = this.getViewportSize();\n      element.sticky.rect = this.getRectangle(element);\n      element.sticky.container.rect = this.getRectangle(element.sticky.container);\n\n      if (element.sticky.rect.top + element.sticky.rect.height < element.sticky.container.rect.top + element.sticky.container.rect.height && element.sticky.stickyFor < this.vp.width && !element.sticky.active) {\n        element.sticky.active = true;\n      } else if (element.sticky.rect.top + element.sticky.rect.height >= element.sticky.container.rect.top + element.sticky.container.rect.height || element.sticky.stickyFor >= this.vp.width && element.sticky.active) {\n        element.sticky.active = false;\n      }\n\n      this.setPosition(element);\n    }\n    /**\n     * Function which is adding onScrollEvents to window listener and assigns function to element as scrollListener\n     * @function\n     * @param {node} element - Element for which scroll events are initialised\n     */\n\n  }, {\n    key: \"initScrollEvents\",\n    value: function initScrollEvents(element) {\n      var _this4 = this;\n\n      element.sticky.scrollListener = function () {\n        return _this4.onScrollEvents(element);\n      };\n\n      window.addEventListener('scroll', element.sticky.scrollListener);\n    }\n    /**\n     * Removes element listener from scroll event\n     * @function\n     * @param {node} element - Element from which listener is deleted\n     */\n\n  }, {\n    key: \"destroyScrollEvents\",\n    value: function destroyScrollEvents(element) {\n      window.removeEventListener('scroll', element.sticky.scrollListener);\n    }\n    /**\n     * Function which is fired when user scroll window. If element is active, function is invoking setPosition function\n     * @function\n     * @param {node} element - Element for which event function is fired\n     */\n\n  }, {\n    key: \"onScrollEvents\",\n    value: function onScrollEvents(element) {\n      if (element.sticky && element.sticky.active) {\n        this.setPosition(element);\n      }\n    }\n    /**\n     * Main function for the library. Here are some condition calculations and css appending for sticky element when user scroll window\n     * @function\n     * @param {node} element - Element that will be positioned if it's active\n     */\n\n  }, {\n    key: \"setPosition\",\n    value: function setPosition(element) {\n      this.css(element, {\n        position: '',\n        width: '',\n        top: '',\n        left: ''\n      });\n\n      if (this.vp.height < element.sticky.rect.height || !element.sticky.active) {\n        return;\n      }\n\n      if (!element.sticky.rect.width) {\n        element.sticky.rect = this.getRectangle(element);\n      }\n\n      if (element.sticky.wrap) {\n        this.css(element.parentNode, {\n          display: 'block',\n          width: element.sticky.rect.width + 'px',\n          height: element.sticky.rect.height + 'px'\n        });\n      }\n\n      if (element.sticky.rect.top === 0 && element.sticky.container === this.body) {\n        this.css(element, {\n          position: 'fixed',\n          top: element.sticky.rect.top + 'px',\n          left: element.sticky.rect.left + 'px',\n          width: element.sticky.rect.width + 'px'\n        });\n\n        if (element.sticky.stickyClass) {\n          element.classList.add(element.sticky.stickyClass);\n        }\n      } else if (this.scrollTop > element.sticky.rect.top - element.sticky.marginTop) {\n        this.css(element, {\n          position: 'fixed',\n          width: element.sticky.rect.width + 'px',\n          left: element.sticky.rect.left + 'px'\n        });\n\n        if (this.scrollTop + element.sticky.rect.height + element.sticky.marginTop > element.sticky.container.rect.top + element.sticky.container.offsetHeight - element.sticky.marginBottom) {\n          if (element.sticky.stickyClass) {\n            element.classList.remove(element.sticky.stickyClass);\n          }\n\n          this.css(element, {\n            top: element.sticky.container.rect.top + element.sticky.container.offsetHeight - (this.scrollTop + element.sticky.rect.height + element.sticky.marginBottom) + 'px'\n          });\n        } else {\n          if (element.sticky.stickyClass) {\n            element.classList.add(element.sticky.stickyClass);\n          }\n\n          this.css(element, {\n            top: element.sticky.marginTop + 'px'\n          });\n        }\n      } else {\n        if (element.sticky.stickyClass) {\n          element.classList.remove(element.sticky.stickyClass);\n        }\n\n        this.css(element, {\n          position: '',\n          width: '',\n          top: '',\n          left: ''\n        });\n\n        if (element.sticky.wrap) {\n          this.css(element.parentNode, {\n            display: '',\n            width: '',\n            height: ''\n          });\n        }\n      }\n    }\n    /**\n     * Function that updates element sticky rectangle (with sticky container), then activate or deactivate element, then update position if it's active\n     * @function\n     */\n\n  }, {\n    key: \"update\",\n    value: function update() {\n      var _this5 = this;\n\n      this.forEach(this.elements, function (element) {\n        element.sticky.rect = _this5.getRectangle(element);\n        element.sticky.container.rect = _this5.getRectangle(element.sticky.container);\n\n        _this5.activate(element);\n\n        _this5.setPosition(element);\n      });\n    }\n    /**\n     * Destroys sticky element, remove listeners\n     * @function\n     */\n\n  }, {\n    key: \"destroy\",\n    value: function destroy() {\n      var _this6 = this;\n\n      window.removeEventListener('load', this.updateScrollTopPosition);\n      window.removeEventListener('scroll', this.updateScrollTopPosition);\n      this.forEach(this.elements, function (element) {\n        _this6.destroyResizeEvents(element);\n\n        _this6.destroyScrollEvents(element);\n\n        delete element.sticky;\n      });\n    }\n    /**\n     * Function that returns container element in which sticky element is stuck (if is not specified, then it's stuck to body)\n     * @function\n     * @param {node} element - Element which sticky container are looked for\n     * @return {node} element - Sticky container\n     */\n\n  }, {\n    key: \"getStickyContainer\",\n    value: function getStickyContainer(element) {\n      var container = element.parentNode;\n\n      while (!container.hasAttribute('data-sticky-container') && !container.parentNode.querySelector(element.sticky.stickyContainer) && container !== this.body) {\n        container = container.parentNode;\n      }\n\n      return container;\n    }\n    /**\n     * Function that returns element rectangle & position (width, height, top, left)\n     * @function\n     * @param {node} element - Element which position & rectangle are returned\n     * @return {object}\n     */\n\n  }, {\n    key: \"getRectangle\",\n    value: function getRectangle(element) {\n      this.css(element, {\n        position: '',\n        width: '',\n        top: '',\n        left: ''\n      });\n      var width = Math.max(element.offsetWidth, element.clientWidth, element.scrollWidth);\n      var height = Math.max(element.offsetHeight, element.clientHeight, element.scrollHeight);\n      var top = 0;\n      var left = 0;\n\n      do {\n        top += element.offsetTop || 0;\n        left += element.offsetLeft || 0;\n        element = element.offsetParent;\n      } while (element);\n\n      return {\n        top: top,\n        left: left,\n        width: width,\n        height: height\n      };\n    }\n    /**\n     * Function that returns viewport dimensions\n     * @function\n     * @return {object}\n     */\n\n  }, {\n    key: \"getViewportSize\",\n    value: function getViewportSize() {\n      return {\n        width: Math.max(document.documentElement.clientWidth, window.innerWidth || 0),\n        height: Math.max(document.documentElement.clientHeight, window.innerHeight || 0)\n      };\n    }\n    /**\n     * Function that updates window scroll position\n     * @function\n     * @return {number}\n     */\n\n  }, {\n    key: \"updateScrollTopPosition\",\n    value: function updateScrollTopPosition() {\n      this.scrollTop = (window.pageYOffset || document.scrollTop) - (document.clientTop || 0) || 0;\n    }\n    /**\n     * Helper function for loops\n     * @helper\n     * @param {array}\n     * @param {function} callback - Callback function (no need for explanation)\n     */\n\n  }, {\n    key: \"forEach\",\n    value: function forEach(array, callback) {\n      for (var i = 0, len = array.length; i < len; i++) {\n        callback(array[i]);\n      }\n    }\n    /**\n     * Helper function to add/remove css properties for specified element.\n     * @helper\n     * @param {node} element - DOM element\n     * @param {object} properties - CSS properties that will be added/removed from specified element\n     */\n\n  }, {\n    key: \"css\",\n    value: function css(element, properties) {\n      for (var property in properties) {\n        if (properties.hasOwnProperty(property)) {\n          element.style[property] = properties[property];\n        }\n      }\n    }\n  }]);\n\n  return Sticky;\n}();\n/**\n * Export function that supports AMD, CommonJS and Plain Browser.\n */\n\n\n(function (root, factory) {\n  if (true) {\n    module.exports = factory;\n  } else {}\n})(this, Sticky);//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHNzcikvLi9ub2RlX21vZHVsZXMvc3RpY2t5LWpzL2Rpc3Qvc3RpY2t5LmNvbXBpbGUuanMiLCJtYXBwaW5ncyI6IkFBQUEsa0RBQWtELDBDQUEwQzs7QUFFNUYsNENBQTRDLGdCQUFnQixrQkFBa0IsT0FBTywyQkFBMkIsd0RBQXdELGdDQUFnQyx1REFBdUQ7O0FBRS9QLDhEQUE4RCxzRUFBc0UsOERBQThEOztBQUVsTTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsYUFBYSxRQUFRO0FBQ3JCLGFBQWEsUUFBUSw0RUFBNEUsT0FBTztBQUN4RztBQUNBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7OztBQUdBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBLFdBQVc7QUFDWDtBQUNBLE9BQU87QUFDUDtBQUNBO0FBQ0E7QUFDQTtBQUNBLGVBQWUsTUFBTTtBQUNyQjs7QUFFQSxHQUFHO0FBQ0g7QUFDQTtBQUNBOztBQUVBO0FBQ0EsMkJBQTJCOztBQUUzQjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsaUdBQWlHO0FBQ2pHOztBQUVBO0FBQ0E7QUFDQTtBQUNBLHdEQUF3RDs7QUFFeEQ7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0EsUUFBUTs7O0FBR1I7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGVBQWUsTUFBTTtBQUNyQjs7QUFFQSxHQUFHO0FBQ0g7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGVBQWUsTUFBTTtBQUNyQjs7QUFFQSxHQUFHO0FBQ0g7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGVBQWUsTUFBTTtBQUNyQjs7QUFFQSxHQUFHO0FBQ0g7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsZUFBZSxNQUFNO0FBQ3JCOztBQUVBLEdBQUc7QUFDSDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGVBQWUsTUFBTTtBQUNyQjs7QUFFQSxHQUFHO0FBQ0g7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0EsUUFBUTtBQUNSO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGVBQWUsTUFBTTtBQUNyQjs7QUFFQSxHQUFHO0FBQ0g7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsZUFBZSxNQUFNO0FBQ3JCOztBQUVBLEdBQUc7QUFDSDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGVBQWUsTUFBTTtBQUNyQjs7QUFFQSxHQUFHO0FBQ0g7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsZUFBZSxNQUFNO0FBQ3JCOztBQUVBLEdBQUc7QUFDSDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE9BQU87O0FBRVA7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsU0FBUztBQUNUOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFNBQVM7O0FBRVQ7QUFDQTtBQUNBO0FBQ0EsUUFBUTtBQUNSO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsU0FBUzs7QUFFVDtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0EsV0FBVztBQUNYLFVBQVU7QUFDVjtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBLFdBQVc7QUFDWDtBQUNBLFFBQVE7QUFDUjtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFNBQVM7O0FBRVQ7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFdBQVc7QUFDWDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQSxHQUFHO0FBQ0g7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTtBQUNBLE9BQU87QUFDUDtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBLEdBQUc7QUFDSDtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQSxPQUFPO0FBQ1A7QUFDQTtBQUNBO0FBQ0E7QUFDQSxlQUFlLE1BQU07QUFDckIsZ0JBQWdCLE1BQU07QUFDdEI7O0FBRUEsR0FBRztBQUNIO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGVBQWUsTUFBTTtBQUNyQixnQkFBZ0I7QUFDaEI7O0FBRUEsR0FBRztBQUNIO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsT0FBTztBQUNQO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsUUFBUTs7QUFFUjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGdCQUFnQjtBQUNoQjs7QUFFQSxHQUFHO0FBQ0g7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxnQkFBZ0I7QUFDaEI7O0FBRUEsR0FBRztBQUNIO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsZUFBZTtBQUNmLGVBQWUsVUFBVTtBQUN6Qjs7QUFFQSxHQUFHO0FBQ0g7QUFDQTtBQUNBLDBDQUEwQyxTQUFTO0FBQ25EO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGVBQWUsTUFBTTtBQUNyQixlQUFlLFFBQVE7QUFDdkI7O0FBRUEsR0FBRztBQUNIO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxHQUFHOztBQUVIO0FBQ0EsQ0FBQztBQUNEO0FBQ0E7QUFDQTs7O0FBR0E7QUFDQSxNQUFNLElBQThCO0FBQ3BDO0FBQ0EsSUFBSSxLQUFLLEVBTU47QUFDSCxDQUFDIiwic291cmNlcyI6WyJ3ZWJwYWNrOi8vc3RhcmJlbGx5LW5leHRqcy8uL25vZGVfbW9kdWxlcy9zdGlja3ktanMvZGlzdC9zdGlja3kuY29tcGlsZS5qcz9jMDQ4Il0sInNvdXJjZXNDb250ZW50IjpbImZ1bmN0aW9uIF9jbGFzc0NhbGxDaGVjayhpbnN0YW5jZSwgQ29uc3RydWN0b3IpIHsgaWYgKCEoaW5zdGFuY2UgaW5zdGFuY2VvZiBDb25zdHJ1Y3RvcikpIHsgdGhyb3cgbmV3IFR5cGVFcnJvcihcIkNhbm5vdCBjYWxsIGEgY2xhc3MgYXMgYSBmdW5jdGlvblwiKTsgfSB9XG5cbmZ1bmN0aW9uIF9kZWZpbmVQcm9wZXJ0aWVzKHRhcmdldCwgcHJvcHMpIHsgZm9yICh2YXIgaSA9IDA7IGkgPCBwcm9wcy5sZW5ndGg7IGkrKykgeyB2YXIgZGVzY3JpcHRvciA9IHByb3BzW2ldOyBkZXNjcmlwdG9yLmVudW1lcmFibGUgPSBkZXNjcmlwdG9yLmVudW1lcmFibGUgfHwgZmFsc2U7IGRlc2NyaXB0b3IuY29uZmlndXJhYmxlID0gdHJ1ZTsgaWYgKFwidmFsdWVcIiBpbiBkZXNjcmlwdG9yKSBkZXNjcmlwdG9yLndyaXRhYmxlID0gdHJ1ZTsgT2JqZWN0LmRlZmluZVByb3BlcnR5KHRhcmdldCwgZGVzY3JpcHRvci5rZXksIGRlc2NyaXB0b3IpOyB9IH1cblxuZnVuY3Rpb24gX2NyZWF0ZUNsYXNzKENvbnN0cnVjdG9yLCBwcm90b1Byb3BzLCBzdGF0aWNQcm9wcykgeyBpZiAocHJvdG9Qcm9wcykgX2RlZmluZVByb3BlcnRpZXMoQ29uc3RydWN0b3IucHJvdG90eXBlLCBwcm90b1Byb3BzKTsgaWYgKHN0YXRpY1Byb3BzKSBfZGVmaW5lUHJvcGVydGllcyhDb25zdHJ1Y3Rvciwgc3RhdGljUHJvcHMpOyByZXR1cm4gQ29uc3RydWN0b3I7IH1cblxuLyoqXG4gKiBTdGlja3kuanNcbiAqIExpYnJhcnkgZm9yIHN0aWNreSBlbGVtZW50cyB3cml0dGVuIGluIHZhbmlsbGEgamF2YXNjcmlwdC4gV2l0aCB0aGlzIGxpYnJhcnkgeW91IGNhbiBlYXNpbHkgc2V0IHN0aWNreSBlbGVtZW50cyBvbiB5b3VyIHdlYnNpdGUuIEl0J3MgYWxzbyByZXNwb25zaXZlLlxuICpcbiAqIEB2ZXJzaW9uIDEuMy4wXG4gKiBAYXV0aG9yIFJhZmFsIEdhbHVzIDxiaXVyb0ByYWZhbGdhbHVzLnBsPlxuICogQHdlYnNpdGUgaHR0cHM6Ly9yZ2FsdXMuZ2l0aHViLmlvL3N0aWNreS1qcy9cbiAqIEByZXBvIGh0dHBzOi8vZ2l0aHViLmNvbS9yZ2FsdXMvc3RpY2t5LWpzXG4gKiBAbGljZW5zZSBodHRwczovL2dpdGh1Yi5jb20vcmdhbHVzL3N0aWNreS1qcy9ibG9iL21hc3Rlci9MSUNFTlNFXG4gKi9cbnZhciBTdGlja3kgPSAvKiNfX1BVUkVfXyovZnVuY3Rpb24gKCkge1xuICAvKipcbiAgICogU3RpY2t5IGluc3RhbmNlIGNvbnN0cnVjdG9yXG4gICAqIEBjb25zdHJ1Y3RvclxuICAgKiBAcGFyYW0ge3N0cmluZ30gc2VsZWN0b3IgLSBTZWxlY3RvciB3aGljaCB3ZSBjYW4gZmluZCBlbGVtZW50c1xuICAgKiBAcGFyYW0ge3N0cmluZ30gb3B0aW9ucyAtIEdsb2JhbCBvcHRpb25zIGZvciBzdGlja3kgZWxlbWVudHMgKGNvdWxkIGJlIG92ZXJ3cml0dGVuIGJ5IGRhdGEte29wdGlvbn09XCJcIiBhdHRyaWJ1dGVzKVxuICAgKi9cbiAgZnVuY3Rpb24gU3RpY2t5KCkge1xuICAgIHZhciBzZWxlY3RvciA9IGFyZ3VtZW50cy5sZW5ndGggPiAwICYmIGFyZ3VtZW50c1swXSAhPT0gdW5kZWZpbmVkID8gYXJndW1lbnRzWzBdIDogJyc7XG4gICAgdmFyIG9wdGlvbnMgPSBhcmd1bWVudHMubGVuZ3RoID4gMSAmJiBhcmd1bWVudHNbMV0gIT09IHVuZGVmaW5lZCA/IGFyZ3VtZW50c1sxXSA6IHt9O1xuXG4gICAgX2NsYXNzQ2FsbENoZWNrKHRoaXMsIFN0aWNreSk7XG5cbiAgICB0aGlzLnNlbGVjdG9yID0gc2VsZWN0b3I7XG4gICAgdGhpcy5lbGVtZW50cyA9IFtdO1xuICAgIHRoaXMudmVyc2lvbiA9ICcxLjMuMCc7XG4gICAgdGhpcy52cCA9IHRoaXMuZ2V0Vmlld3BvcnRTaXplKCk7XG4gICAgdGhpcy5ib2R5ID0gZG9jdW1lbnQucXVlcnlTZWxlY3RvcignYm9keScpO1xuICAgIHRoaXMub3B0aW9ucyA9IHtcbiAgICAgIHdyYXA6IG9wdGlvbnMud3JhcCB8fCBmYWxzZSxcbiAgICAgIHdyYXBXaXRoOiBvcHRpb25zLndyYXBXaXRoIHx8ICc8c3Bhbj48L3NwYW4+JyxcbiAgICAgIG1hcmdpblRvcDogb3B0aW9ucy5tYXJnaW5Ub3AgfHwgMCxcbiAgICAgIG1hcmdpbkJvdHRvbTogb3B0aW9ucy5tYXJnaW5Cb3R0b20gfHwgMCxcbiAgICAgIHN0aWNreUZvcjogb3B0aW9ucy5zdGlja3lGb3IgfHwgMCxcbiAgICAgIHN0aWNreUNsYXNzOiBvcHRpb25zLnN0aWNreUNsYXNzIHx8IG51bGwsXG4gICAgICBzdGlja3lDb250YWluZXI6IG9wdGlvbnMuc3RpY2t5Q29udGFpbmVyIHx8ICdib2R5J1xuICAgIH07XG4gICAgdGhpcy51cGRhdGVTY3JvbGxUb3BQb3NpdGlvbiA9IHRoaXMudXBkYXRlU2Nyb2xsVG9wUG9zaXRpb24uYmluZCh0aGlzKTtcbiAgICB0aGlzLnVwZGF0ZVNjcm9sbFRvcFBvc2l0aW9uKCk7XG4gICAgd2luZG93LmFkZEV2ZW50TGlzdGVuZXIoJ2xvYWQnLCB0aGlzLnVwZGF0ZVNjcm9sbFRvcFBvc2l0aW9uKTtcbiAgICB3aW5kb3cuYWRkRXZlbnRMaXN0ZW5lcignc2Nyb2xsJywgdGhpcy51cGRhdGVTY3JvbGxUb3BQb3NpdGlvbik7XG4gICAgdGhpcy5ydW4oKTtcbiAgfVxuICAvKipcbiAgICogRnVuY3Rpb24gdGhhdCB3YWl0cyBmb3IgcGFnZSB0byBiZSBmdWxseSBsb2FkZWQgYW5kIHRoZW4gcmVuZGVycyAmIGFjdGl2YXRlcyBldmVyeSBzdGlja3kgZWxlbWVudCBmb3VuZCB3aXRoIHNwZWNpZmllZCBzZWxlY3RvclxuICAgKiBAZnVuY3Rpb25cbiAgICovXG5cblxuICBfY3JlYXRlQ2xhc3MoU3RpY2t5LCBbe1xuICAgIGtleTogXCJydW5cIixcbiAgICB2YWx1ZTogZnVuY3Rpb24gcnVuKCkge1xuICAgICAgdmFyIF90aGlzID0gdGhpcztcblxuICAgICAgLy8gd2FpdCBmb3IgcGFnZSB0byBiZSBmdWxseSBsb2FkZWRcbiAgICAgIHZhciBwYWdlTG9hZGVkID0gc2V0SW50ZXJ2YWwoZnVuY3Rpb24gKCkge1xuICAgICAgICBpZiAoZG9jdW1lbnQucmVhZHlTdGF0ZSA9PT0gJ2NvbXBsZXRlJykge1xuICAgICAgICAgIGNsZWFySW50ZXJ2YWwocGFnZUxvYWRlZCk7XG4gICAgICAgICAgdmFyIGVsZW1lbnRzID0gZG9jdW1lbnQucXVlcnlTZWxlY3RvckFsbChfdGhpcy5zZWxlY3Rvcik7XG5cbiAgICAgICAgICBfdGhpcy5mb3JFYWNoKGVsZW1lbnRzLCBmdW5jdGlvbiAoZWxlbWVudCkge1xuICAgICAgICAgICAgcmV0dXJuIF90aGlzLnJlbmRlckVsZW1lbnQoZWxlbWVudCk7XG4gICAgICAgICAgfSk7XG4gICAgICAgIH1cbiAgICAgIH0sIDEwKTtcbiAgICB9XG4gICAgLyoqXG4gICAgICogRnVuY3Rpb24gdGhhdCBhc3NpZ24gbmVlZGVkIHZhcmlhYmxlcyBmb3Igc3RpY2t5IGVsZW1lbnQsIHRoYXQgYXJlIHVzZWQgaW4gZnV0dXJlIGZvciBjYWxjdWxhdGlvbnMgYW5kIG90aGVyXG4gICAgICogQGZ1bmN0aW9uXG4gICAgICogQHBhcmFtIHtub2RlfSBlbGVtZW50IC0gRWxlbWVudCB0byBiZSByZW5kZXJlZFxuICAgICAqL1xuXG4gIH0sIHtcbiAgICBrZXk6IFwicmVuZGVyRWxlbWVudFwiLFxuICAgIHZhbHVlOiBmdW5jdGlvbiByZW5kZXJFbGVtZW50KGVsZW1lbnQpIHtcbiAgICAgIHZhciBfdGhpczIgPSB0aGlzO1xuXG4gICAgICAvLyBjcmVhdGUgY29udGFpbmVyIGZvciB2YXJpYWJsZXMgbmVlZGVkIGluIGZ1dHVyZVxuICAgICAgZWxlbWVudC5zdGlja3kgPSB7fTsgLy8gc2V0IGRlZmF1bHQgdmFyaWFibGVzXG5cbiAgICAgIGVsZW1lbnQuc3RpY2t5LmFjdGl2ZSA9IGZhbHNlO1xuICAgICAgZWxlbWVudC5zdGlja3kubWFyZ2luVG9wID0gcGFyc2VJbnQoZWxlbWVudC5nZXRBdHRyaWJ1dGUoJ2RhdGEtbWFyZ2luLXRvcCcpKSB8fCB0aGlzLm9wdGlvbnMubWFyZ2luVG9wO1xuICAgICAgZWxlbWVudC5zdGlja3kubWFyZ2luQm90dG9tID0gcGFyc2VJbnQoZWxlbWVudC5nZXRBdHRyaWJ1dGUoJ2RhdGEtbWFyZ2luLWJvdHRvbScpKSB8fCB0aGlzLm9wdGlvbnMubWFyZ2luQm90dG9tO1xuICAgICAgZWxlbWVudC5zdGlja3kuc3RpY2t5Rm9yID0gcGFyc2VJbnQoZWxlbWVudC5nZXRBdHRyaWJ1dGUoJ2RhdGEtc3RpY2t5LWZvcicpKSB8fCB0aGlzLm9wdGlvbnMuc3RpY2t5Rm9yO1xuICAgICAgZWxlbWVudC5zdGlja3kuc3RpY2t5Q2xhc3MgPSBlbGVtZW50LmdldEF0dHJpYnV0ZSgnZGF0YS1zdGlja3ktY2xhc3MnKSB8fCB0aGlzLm9wdGlvbnMuc3RpY2t5Q2xhc3M7XG4gICAgICBlbGVtZW50LnN0aWNreS53cmFwID0gZWxlbWVudC5oYXNBdHRyaWJ1dGUoJ2RhdGEtc3RpY2t5LXdyYXAnKSA/IHRydWUgOiB0aGlzLm9wdGlvbnMud3JhcDsgLy8gQHRvZG8gYXR0cmlidXRlIGZvciBzdGlja3lDb250YWluZXJcbiAgICAgIC8vIGVsZW1lbnQuc3RpY2t5LnN0aWNreUNvbnRhaW5lciA9IGVsZW1lbnQuZ2V0QXR0cmlidXRlKCdkYXRhLXN0aWNreS1jb250YWluZXInKSB8fCB0aGlzLm9wdGlvbnMuc3RpY2t5Q29udGFpbmVyO1xuXG4gICAgICBlbGVtZW50LnN0aWNreS5zdGlja3lDb250YWluZXIgPSB0aGlzLm9wdGlvbnMuc3RpY2t5Q29udGFpbmVyO1xuICAgICAgZWxlbWVudC5zdGlja3kuY29udGFpbmVyID0gdGhpcy5nZXRTdGlja3lDb250YWluZXIoZWxlbWVudCk7XG4gICAgICBlbGVtZW50LnN0aWNreS5jb250YWluZXIucmVjdCA9IHRoaXMuZ2V0UmVjdGFuZ2xlKGVsZW1lbnQuc3RpY2t5LmNvbnRhaW5lcik7XG4gICAgICBlbGVtZW50LnN0aWNreS5yZWN0ID0gdGhpcy5nZXRSZWN0YW5nbGUoZWxlbWVudCk7IC8vIGZpeCB3aGVuIGVsZW1lbnQgaXMgaW1hZ2UgdGhhdCBoYXMgbm90IHlldCBsb2FkZWQgYW5kIHdpZHRoLCBoZWlnaHQgPSAwXG5cbiAgICAgIGlmIChlbGVtZW50LnRhZ05hbWUudG9Mb3dlckNhc2UoKSA9PT0gJ2ltZycpIHtcbiAgICAgICAgZWxlbWVudC5vbmxvYWQgPSBmdW5jdGlvbiAoKSB7XG4gICAgICAgICAgcmV0dXJuIGVsZW1lbnQuc3RpY2t5LnJlY3QgPSBfdGhpczIuZ2V0UmVjdGFuZ2xlKGVsZW1lbnQpO1xuICAgICAgICB9O1xuICAgICAgfVxuXG4gICAgICBpZiAoZWxlbWVudC5zdGlja3kud3JhcCkge1xuICAgICAgICB0aGlzLndyYXBFbGVtZW50KGVsZW1lbnQpO1xuICAgICAgfSAvLyBhY3RpdmF0ZSByZW5kZXJlZCBlbGVtZW50XG5cblxuICAgICAgdGhpcy5hY3RpdmF0ZShlbGVtZW50KTtcbiAgICB9XG4gICAgLyoqXG4gICAgICogV3JhcHMgZWxlbWVudCBpbnRvIHBsYWNlaG9sZGVyIGVsZW1lbnRcbiAgICAgKiBAZnVuY3Rpb25cbiAgICAgKiBAcGFyYW0ge25vZGV9IGVsZW1lbnQgLSBFbGVtZW50IHRvIGJlIHdyYXBwZWRcbiAgICAgKi9cblxuICB9LCB7XG4gICAga2V5OiBcIndyYXBFbGVtZW50XCIsXG4gICAgdmFsdWU6IGZ1bmN0aW9uIHdyYXBFbGVtZW50KGVsZW1lbnQpIHtcbiAgICAgIGVsZW1lbnQuaW5zZXJ0QWRqYWNlbnRIVE1MKCdiZWZvcmViZWdpbicsIGVsZW1lbnQuZ2V0QXR0cmlidXRlKCdkYXRhLXN0aWNreS13cmFwV2l0aCcpIHx8IHRoaXMub3B0aW9ucy53cmFwV2l0aCk7XG4gICAgICBlbGVtZW50LnByZXZpb3VzU2libGluZy5hcHBlbmRDaGlsZChlbGVtZW50KTtcbiAgICB9XG4gICAgLyoqXG4gICAgICogRnVuY3Rpb24gdGhhdCBhY3RpdmF0ZXMgZWxlbWVudCB3aGVuIHNwZWNpZmllZCBjb25kaXRpb25zIGFyZSBtZXQgYW5kIHRoZW4gaW5pdGFsaXNlIGV2ZW50c1xuICAgICAqIEBmdW5jdGlvblxuICAgICAqIEBwYXJhbSB7bm9kZX0gZWxlbWVudCAtIEVsZW1lbnQgdG8gYmUgYWN0aXZhdGVkXG4gICAgICovXG5cbiAgfSwge1xuICAgIGtleTogXCJhY3RpdmF0ZVwiLFxuICAgIHZhbHVlOiBmdW5jdGlvbiBhY3RpdmF0ZShlbGVtZW50KSB7XG4gICAgICBpZiAoZWxlbWVudC5zdGlja3kucmVjdC50b3AgKyBlbGVtZW50LnN0aWNreS5yZWN0LmhlaWdodCA8IGVsZW1lbnQuc3RpY2t5LmNvbnRhaW5lci5yZWN0LnRvcCArIGVsZW1lbnQuc3RpY2t5LmNvbnRhaW5lci5yZWN0LmhlaWdodCAmJiBlbGVtZW50LnN0aWNreS5zdGlja3lGb3IgPCB0aGlzLnZwLndpZHRoICYmICFlbGVtZW50LnN0aWNreS5hY3RpdmUpIHtcbiAgICAgICAgZWxlbWVudC5zdGlja3kuYWN0aXZlID0gdHJ1ZTtcbiAgICAgIH1cblxuICAgICAgaWYgKHRoaXMuZWxlbWVudHMuaW5kZXhPZihlbGVtZW50KSA8IDApIHtcbiAgICAgICAgdGhpcy5lbGVtZW50cy5wdXNoKGVsZW1lbnQpO1xuICAgICAgfVxuXG4gICAgICBpZiAoIWVsZW1lbnQuc3RpY2t5LnJlc2l6ZUV2ZW50KSB7XG4gICAgICAgIHRoaXMuaW5pdFJlc2l6ZUV2ZW50cyhlbGVtZW50KTtcbiAgICAgICAgZWxlbWVudC5zdGlja3kucmVzaXplRXZlbnQgPSB0cnVlO1xuICAgICAgfVxuXG4gICAgICBpZiAoIWVsZW1lbnQuc3RpY2t5LnNjcm9sbEV2ZW50KSB7XG4gICAgICAgIHRoaXMuaW5pdFNjcm9sbEV2ZW50cyhlbGVtZW50KTtcbiAgICAgICAgZWxlbWVudC5zdGlja3kuc2Nyb2xsRXZlbnQgPSB0cnVlO1xuICAgICAgfVxuXG4gICAgICB0aGlzLnNldFBvc2l0aW9uKGVsZW1lbnQpO1xuICAgIH1cbiAgICAvKipcbiAgICAgKiBGdW5jdGlvbiB3aGljaCBpcyBhZGRpbmcgb25SZXNpemVFdmVudHMgdG8gd2luZG93IGxpc3RlbmVyIGFuZCBhc3NpZ25zIGZ1bmN0aW9uIHRvIGVsZW1lbnQgYXMgcmVzaXplTGlzdGVuZXJcbiAgICAgKiBAZnVuY3Rpb25cbiAgICAgKiBAcGFyYW0ge25vZGV9IGVsZW1lbnQgLSBFbGVtZW50IGZvciB3aGljaCByZXNpemUgZXZlbnRzIGFyZSBpbml0aWFsaXNlZFxuICAgICAqL1xuXG4gIH0sIHtcbiAgICBrZXk6IFwiaW5pdFJlc2l6ZUV2ZW50c1wiLFxuICAgIHZhbHVlOiBmdW5jdGlvbiBpbml0UmVzaXplRXZlbnRzKGVsZW1lbnQpIHtcbiAgICAgIHZhciBfdGhpczMgPSB0aGlzO1xuXG4gICAgICBlbGVtZW50LnN0aWNreS5yZXNpemVMaXN0ZW5lciA9IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgcmV0dXJuIF90aGlzMy5vblJlc2l6ZUV2ZW50cyhlbGVtZW50KTtcbiAgICAgIH07XG5cbiAgICAgIHdpbmRvdy5hZGRFdmVudExpc3RlbmVyKCdyZXNpemUnLCBlbGVtZW50LnN0aWNreS5yZXNpemVMaXN0ZW5lcik7XG4gICAgfVxuICAgIC8qKlxuICAgICAqIFJlbW92ZXMgZWxlbWVudCBsaXN0ZW5lciBmcm9tIHJlc2l6ZSBldmVudFxuICAgICAqIEBmdW5jdGlvblxuICAgICAqIEBwYXJhbSB7bm9kZX0gZWxlbWVudCAtIEVsZW1lbnQgZnJvbSB3aGljaCBsaXN0ZW5lciBpcyBkZWxldGVkXG4gICAgICovXG5cbiAgfSwge1xuICAgIGtleTogXCJkZXN0cm95UmVzaXplRXZlbnRzXCIsXG4gICAgdmFsdWU6IGZ1bmN0aW9uIGRlc3Ryb3lSZXNpemVFdmVudHMoZWxlbWVudCkge1xuICAgICAgd2luZG93LnJlbW92ZUV2ZW50TGlzdGVuZXIoJ3Jlc2l6ZScsIGVsZW1lbnQuc3RpY2t5LnJlc2l6ZUxpc3RlbmVyKTtcbiAgICB9XG4gICAgLyoqXG4gICAgICogRnVuY3Rpb24gd2hpY2ggaXMgZmlyZWQgd2hlbiB1c2VyIHJlc2l6ZSB3aW5kb3cuIEl0IGNoZWNrcyBpZiBlbGVtZW50IHNob3VsZCBiZSBhY3RpdmF0ZWQgb3IgZGVhY3RpdmF0ZWQgYW5kIHRoZW4gcnVuIHNldFBvc2l0aW9uIGZ1bmN0aW9uXG4gICAgICogQGZ1bmN0aW9uXG4gICAgICogQHBhcmFtIHtub2RlfSBlbGVtZW50IC0gRWxlbWVudCBmb3Igd2hpY2ggZXZlbnQgZnVuY3Rpb24gaXMgZmlyZWRcbiAgICAgKi9cblxuICB9LCB7XG4gICAga2V5OiBcIm9uUmVzaXplRXZlbnRzXCIsXG4gICAgdmFsdWU6IGZ1bmN0aW9uIG9uUmVzaXplRXZlbnRzKGVsZW1lbnQpIHtcbiAgICAgIHRoaXMudnAgPSB0aGlzLmdldFZpZXdwb3J0U2l6ZSgpO1xuICAgICAgZWxlbWVudC5zdGlja3kucmVjdCA9IHRoaXMuZ2V0UmVjdGFuZ2xlKGVsZW1lbnQpO1xuICAgICAgZWxlbWVudC5zdGlja3kuY29udGFpbmVyLnJlY3QgPSB0aGlzLmdldFJlY3RhbmdsZShlbGVtZW50LnN0aWNreS5jb250YWluZXIpO1xuXG4gICAgICBpZiAoZWxlbWVudC5zdGlja3kucmVjdC50b3AgKyBlbGVtZW50LnN0aWNreS5yZWN0LmhlaWdodCA8IGVsZW1lbnQuc3RpY2t5LmNvbnRhaW5lci5yZWN0LnRvcCArIGVsZW1lbnQuc3RpY2t5LmNvbnRhaW5lci5yZWN0LmhlaWdodCAmJiBlbGVtZW50LnN0aWNreS5zdGlja3lGb3IgPCB0aGlzLnZwLndpZHRoICYmICFlbGVtZW50LnN0aWNreS5hY3RpdmUpIHtcbiAgICAgICAgZWxlbWVudC5zdGlja3kuYWN0aXZlID0gdHJ1ZTtcbiAgICAgIH0gZWxzZSBpZiAoZWxlbWVudC5zdGlja3kucmVjdC50b3AgKyBlbGVtZW50LnN0aWNreS5yZWN0LmhlaWdodCA+PSBlbGVtZW50LnN0aWNreS5jb250YWluZXIucmVjdC50b3AgKyBlbGVtZW50LnN0aWNreS5jb250YWluZXIucmVjdC5oZWlnaHQgfHwgZWxlbWVudC5zdGlja3kuc3RpY2t5Rm9yID49IHRoaXMudnAud2lkdGggJiYgZWxlbWVudC5zdGlja3kuYWN0aXZlKSB7XG4gICAgICAgIGVsZW1lbnQuc3RpY2t5LmFjdGl2ZSA9IGZhbHNlO1xuICAgICAgfVxuXG4gICAgICB0aGlzLnNldFBvc2l0aW9uKGVsZW1lbnQpO1xuICAgIH1cbiAgICAvKipcbiAgICAgKiBGdW5jdGlvbiB3aGljaCBpcyBhZGRpbmcgb25TY3JvbGxFdmVudHMgdG8gd2luZG93IGxpc3RlbmVyIGFuZCBhc3NpZ25zIGZ1bmN0aW9uIHRvIGVsZW1lbnQgYXMgc2Nyb2xsTGlzdGVuZXJcbiAgICAgKiBAZnVuY3Rpb25cbiAgICAgKiBAcGFyYW0ge25vZGV9IGVsZW1lbnQgLSBFbGVtZW50IGZvciB3aGljaCBzY3JvbGwgZXZlbnRzIGFyZSBpbml0aWFsaXNlZFxuICAgICAqL1xuXG4gIH0sIHtcbiAgICBrZXk6IFwiaW5pdFNjcm9sbEV2ZW50c1wiLFxuICAgIHZhbHVlOiBmdW5jdGlvbiBpbml0U2Nyb2xsRXZlbnRzKGVsZW1lbnQpIHtcbiAgICAgIHZhciBfdGhpczQgPSB0aGlzO1xuXG4gICAgICBlbGVtZW50LnN0aWNreS5zY3JvbGxMaXN0ZW5lciA9IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgcmV0dXJuIF90aGlzNC5vblNjcm9sbEV2ZW50cyhlbGVtZW50KTtcbiAgICAgIH07XG5cbiAgICAgIHdpbmRvdy5hZGRFdmVudExpc3RlbmVyKCdzY3JvbGwnLCBlbGVtZW50LnN0aWNreS5zY3JvbGxMaXN0ZW5lcik7XG4gICAgfVxuICAgIC8qKlxuICAgICAqIFJlbW92ZXMgZWxlbWVudCBsaXN0ZW5lciBmcm9tIHNjcm9sbCBldmVudFxuICAgICAqIEBmdW5jdGlvblxuICAgICAqIEBwYXJhbSB7bm9kZX0gZWxlbWVudCAtIEVsZW1lbnQgZnJvbSB3aGljaCBsaXN0ZW5lciBpcyBkZWxldGVkXG4gICAgICovXG5cbiAgfSwge1xuICAgIGtleTogXCJkZXN0cm95U2Nyb2xsRXZlbnRzXCIsXG4gICAgdmFsdWU6IGZ1bmN0aW9uIGRlc3Ryb3lTY3JvbGxFdmVudHMoZWxlbWVudCkge1xuICAgICAgd2luZG93LnJlbW92ZUV2ZW50TGlzdGVuZXIoJ3Njcm9sbCcsIGVsZW1lbnQuc3RpY2t5LnNjcm9sbExpc3RlbmVyKTtcbiAgICB9XG4gICAgLyoqXG4gICAgICogRnVuY3Rpb24gd2hpY2ggaXMgZmlyZWQgd2hlbiB1c2VyIHNjcm9sbCB3aW5kb3cuIElmIGVsZW1lbnQgaXMgYWN0aXZlLCBmdW5jdGlvbiBpcyBpbnZva2luZyBzZXRQb3NpdGlvbiBmdW5jdGlvblxuICAgICAqIEBmdW5jdGlvblxuICAgICAqIEBwYXJhbSB7bm9kZX0gZWxlbWVudCAtIEVsZW1lbnQgZm9yIHdoaWNoIGV2ZW50IGZ1bmN0aW9uIGlzIGZpcmVkXG4gICAgICovXG5cbiAgfSwge1xuICAgIGtleTogXCJvblNjcm9sbEV2ZW50c1wiLFxuICAgIHZhbHVlOiBmdW5jdGlvbiBvblNjcm9sbEV2ZW50cyhlbGVtZW50KSB7XG4gICAgICBpZiAoZWxlbWVudC5zdGlja3kgJiYgZWxlbWVudC5zdGlja3kuYWN0aXZlKSB7XG4gICAgICAgIHRoaXMuc2V0UG9zaXRpb24oZWxlbWVudCk7XG4gICAgICB9XG4gICAgfVxuICAgIC8qKlxuICAgICAqIE1haW4gZnVuY3Rpb24gZm9yIHRoZSBsaWJyYXJ5LiBIZXJlIGFyZSBzb21lIGNvbmRpdGlvbiBjYWxjdWxhdGlvbnMgYW5kIGNzcyBhcHBlbmRpbmcgZm9yIHN0aWNreSBlbGVtZW50IHdoZW4gdXNlciBzY3JvbGwgd2luZG93XG4gICAgICogQGZ1bmN0aW9uXG4gICAgICogQHBhcmFtIHtub2RlfSBlbGVtZW50IC0gRWxlbWVudCB0aGF0IHdpbGwgYmUgcG9zaXRpb25lZCBpZiBpdCdzIGFjdGl2ZVxuICAgICAqL1xuXG4gIH0sIHtcbiAgICBrZXk6IFwic2V0UG9zaXRpb25cIixcbiAgICB2YWx1ZTogZnVuY3Rpb24gc2V0UG9zaXRpb24oZWxlbWVudCkge1xuICAgICAgdGhpcy5jc3MoZWxlbWVudCwge1xuICAgICAgICBwb3NpdGlvbjogJycsXG4gICAgICAgIHdpZHRoOiAnJyxcbiAgICAgICAgdG9wOiAnJyxcbiAgICAgICAgbGVmdDogJydcbiAgICAgIH0pO1xuXG4gICAgICBpZiAodGhpcy52cC5oZWlnaHQgPCBlbGVtZW50LnN0aWNreS5yZWN0LmhlaWdodCB8fCAhZWxlbWVudC5zdGlja3kuYWN0aXZlKSB7XG4gICAgICAgIHJldHVybjtcbiAgICAgIH1cblxuICAgICAgaWYgKCFlbGVtZW50LnN0aWNreS5yZWN0LndpZHRoKSB7XG4gICAgICAgIGVsZW1lbnQuc3RpY2t5LnJlY3QgPSB0aGlzLmdldFJlY3RhbmdsZShlbGVtZW50KTtcbiAgICAgIH1cblxuICAgICAgaWYgKGVsZW1lbnQuc3RpY2t5LndyYXApIHtcbiAgICAgICAgdGhpcy5jc3MoZWxlbWVudC5wYXJlbnROb2RlLCB7XG4gICAgICAgICAgZGlzcGxheTogJ2Jsb2NrJyxcbiAgICAgICAgICB3aWR0aDogZWxlbWVudC5zdGlja3kucmVjdC53aWR0aCArICdweCcsXG4gICAgICAgICAgaGVpZ2h0OiBlbGVtZW50LnN0aWNreS5yZWN0LmhlaWdodCArICdweCdcbiAgICAgICAgfSk7XG4gICAgICB9XG5cbiAgICAgIGlmIChlbGVtZW50LnN0aWNreS5yZWN0LnRvcCA9PT0gMCAmJiBlbGVtZW50LnN0aWNreS5jb250YWluZXIgPT09IHRoaXMuYm9keSkge1xuICAgICAgICB0aGlzLmNzcyhlbGVtZW50LCB7XG4gICAgICAgICAgcG9zaXRpb246ICdmaXhlZCcsXG4gICAgICAgICAgdG9wOiBlbGVtZW50LnN0aWNreS5yZWN0LnRvcCArICdweCcsXG4gICAgICAgICAgbGVmdDogZWxlbWVudC5zdGlja3kucmVjdC5sZWZ0ICsgJ3B4JyxcbiAgICAgICAgICB3aWR0aDogZWxlbWVudC5zdGlja3kucmVjdC53aWR0aCArICdweCdcbiAgICAgICAgfSk7XG5cbiAgICAgICAgaWYgKGVsZW1lbnQuc3RpY2t5LnN0aWNreUNsYXNzKSB7XG4gICAgICAgICAgZWxlbWVudC5jbGFzc0xpc3QuYWRkKGVsZW1lbnQuc3RpY2t5LnN0aWNreUNsYXNzKTtcbiAgICAgICAgfVxuICAgICAgfSBlbHNlIGlmICh0aGlzLnNjcm9sbFRvcCA+IGVsZW1lbnQuc3RpY2t5LnJlY3QudG9wIC0gZWxlbWVudC5zdGlja3kubWFyZ2luVG9wKSB7XG4gICAgICAgIHRoaXMuY3NzKGVsZW1lbnQsIHtcbiAgICAgICAgICBwb3NpdGlvbjogJ2ZpeGVkJyxcbiAgICAgICAgICB3aWR0aDogZWxlbWVudC5zdGlja3kucmVjdC53aWR0aCArICdweCcsXG4gICAgICAgICAgbGVmdDogZWxlbWVudC5zdGlja3kucmVjdC5sZWZ0ICsgJ3B4J1xuICAgICAgICB9KTtcblxuICAgICAgICBpZiAodGhpcy5zY3JvbGxUb3AgKyBlbGVtZW50LnN0aWNreS5yZWN0LmhlaWdodCArIGVsZW1lbnQuc3RpY2t5Lm1hcmdpblRvcCA+IGVsZW1lbnQuc3RpY2t5LmNvbnRhaW5lci5yZWN0LnRvcCArIGVsZW1lbnQuc3RpY2t5LmNvbnRhaW5lci5vZmZzZXRIZWlnaHQgLSBlbGVtZW50LnN0aWNreS5tYXJnaW5Cb3R0b20pIHtcbiAgICAgICAgICBpZiAoZWxlbWVudC5zdGlja3kuc3RpY2t5Q2xhc3MpIHtcbiAgICAgICAgICAgIGVsZW1lbnQuY2xhc3NMaXN0LnJlbW92ZShlbGVtZW50LnN0aWNreS5zdGlja3lDbGFzcyk7XG4gICAgICAgICAgfVxuXG4gICAgICAgICAgdGhpcy5jc3MoZWxlbWVudCwge1xuICAgICAgICAgICAgdG9wOiBlbGVtZW50LnN0aWNreS5jb250YWluZXIucmVjdC50b3AgKyBlbGVtZW50LnN0aWNreS5jb250YWluZXIub2Zmc2V0SGVpZ2h0IC0gKHRoaXMuc2Nyb2xsVG9wICsgZWxlbWVudC5zdGlja3kucmVjdC5oZWlnaHQgKyBlbGVtZW50LnN0aWNreS5tYXJnaW5Cb3R0b20pICsgJ3B4J1xuICAgICAgICAgIH0pO1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgIGlmIChlbGVtZW50LnN0aWNreS5zdGlja3lDbGFzcykge1xuICAgICAgICAgICAgZWxlbWVudC5jbGFzc0xpc3QuYWRkKGVsZW1lbnQuc3RpY2t5LnN0aWNreUNsYXNzKTtcbiAgICAgICAgICB9XG5cbiAgICAgICAgICB0aGlzLmNzcyhlbGVtZW50LCB7XG4gICAgICAgICAgICB0b3A6IGVsZW1lbnQuc3RpY2t5Lm1hcmdpblRvcCArICdweCdcbiAgICAgICAgICB9KTtcbiAgICAgICAgfVxuICAgICAgfSBlbHNlIHtcbiAgICAgICAgaWYgKGVsZW1lbnQuc3RpY2t5LnN0aWNreUNsYXNzKSB7XG4gICAgICAgICAgZWxlbWVudC5jbGFzc0xpc3QucmVtb3ZlKGVsZW1lbnQuc3RpY2t5LnN0aWNreUNsYXNzKTtcbiAgICAgICAgfVxuXG4gICAgICAgIHRoaXMuY3NzKGVsZW1lbnQsIHtcbiAgICAgICAgICBwb3NpdGlvbjogJycsXG4gICAgICAgICAgd2lkdGg6ICcnLFxuICAgICAgICAgIHRvcDogJycsXG4gICAgICAgICAgbGVmdDogJydcbiAgICAgICAgfSk7XG5cbiAgICAgICAgaWYgKGVsZW1lbnQuc3RpY2t5LndyYXApIHtcbiAgICAgICAgICB0aGlzLmNzcyhlbGVtZW50LnBhcmVudE5vZGUsIHtcbiAgICAgICAgICAgIGRpc3BsYXk6ICcnLFxuICAgICAgICAgICAgd2lkdGg6ICcnLFxuICAgICAgICAgICAgaGVpZ2h0OiAnJ1xuICAgICAgICAgIH0pO1xuICAgICAgICB9XG4gICAgICB9XG4gICAgfVxuICAgIC8qKlxuICAgICAqIEZ1bmN0aW9uIHRoYXQgdXBkYXRlcyBlbGVtZW50IHN0aWNreSByZWN0YW5nbGUgKHdpdGggc3RpY2t5IGNvbnRhaW5lciksIHRoZW4gYWN0aXZhdGUgb3IgZGVhY3RpdmF0ZSBlbGVtZW50LCB0aGVuIHVwZGF0ZSBwb3NpdGlvbiBpZiBpdCdzIGFjdGl2ZVxuICAgICAqIEBmdW5jdGlvblxuICAgICAqL1xuXG4gIH0sIHtcbiAgICBrZXk6IFwidXBkYXRlXCIsXG4gICAgdmFsdWU6IGZ1bmN0aW9uIHVwZGF0ZSgpIHtcbiAgICAgIHZhciBfdGhpczUgPSB0aGlzO1xuXG4gICAgICB0aGlzLmZvckVhY2godGhpcy5lbGVtZW50cywgZnVuY3Rpb24gKGVsZW1lbnQpIHtcbiAgICAgICAgZWxlbWVudC5zdGlja3kucmVjdCA9IF90aGlzNS5nZXRSZWN0YW5nbGUoZWxlbWVudCk7XG4gICAgICAgIGVsZW1lbnQuc3RpY2t5LmNvbnRhaW5lci5yZWN0ID0gX3RoaXM1LmdldFJlY3RhbmdsZShlbGVtZW50LnN0aWNreS5jb250YWluZXIpO1xuXG4gICAgICAgIF90aGlzNS5hY3RpdmF0ZShlbGVtZW50KTtcblxuICAgICAgICBfdGhpczUuc2V0UG9zaXRpb24oZWxlbWVudCk7XG4gICAgICB9KTtcbiAgICB9XG4gICAgLyoqXG4gICAgICogRGVzdHJveXMgc3RpY2t5IGVsZW1lbnQsIHJlbW92ZSBsaXN0ZW5lcnNcbiAgICAgKiBAZnVuY3Rpb25cbiAgICAgKi9cblxuICB9LCB7XG4gICAga2V5OiBcImRlc3Ryb3lcIixcbiAgICB2YWx1ZTogZnVuY3Rpb24gZGVzdHJveSgpIHtcbiAgICAgIHZhciBfdGhpczYgPSB0aGlzO1xuXG4gICAgICB3aW5kb3cucmVtb3ZlRXZlbnRMaXN0ZW5lcignbG9hZCcsIHRoaXMudXBkYXRlU2Nyb2xsVG9wUG9zaXRpb24pO1xuICAgICAgd2luZG93LnJlbW92ZUV2ZW50TGlzdGVuZXIoJ3Njcm9sbCcsIHRoaXMudXBkYXRlU2Nyb2xsVG9wUG9zaXRpb24pO1xuICAgICAgdGhpcy5mb3JFYWNoKHRoaXMuZWxlbWVudHMsIGZ1bmN0aW9uIChlbGVtZW50KSB7XG4gICAgICAgIF90aGlzNi5kZXN0cm95UmVzaXplRXZlbnRzKGVsZW1lbnQpO1xuXG4gICAgICAgIF90aGlzNi5kZXN0cm95U2Nyb2xsRXZlbnRzKGVsZW1lbnQpO1xuXG4gICAgICAgIGRlbGV0ZSBlbGVtZW50LnN0aWNreTtcbiAgICAgIH0pO1xuICAgIH1cbiAgICAvKipcbiAgICAgKiBGdW5jdGlvbiB0aGF0IHJldHVybnMgY29udGFpbmVyIGVsZW1lbnQgaW4gd2hpY2ggc3RpY2t5IGVsZW1lbnQgaXMgc3R1Y2sgKGlmIGlzIG5vdCBzcGVjaWZpZWQsIHRoZW4gaXQncyBzdHVjayB0byBib2R5KVxuICAgICAqIEBmdW5jdGlvblxuICAgICAqIEBwYXJhbSB7bm9kZX0gZWxlbWVudCAtIEVsZW1lbnQgd2hpY2ggc3RpY2t5IGNvbnRhaW5lciBhcmUgbG9va2VkIGZvclxuICAgICAqIEByZXR1cm4ge25vZGV9IGVsZW1lbnQgLSBTdGlja3kgY29udGFpbmVyXG4gICAgICovXG5cbiAgfSwge1xuICAgIGtleTogXCJnZXRTdGlja3lDb250YWluZXJcIixcbiAgICB2YWx1ZTogZnVuY3Rpb24gZ2V0U3RpY2t5Q29udGFpbmVyKGVsZW1lbnQpIHtcbiAgICAgIHZhciBjb250YWluZXIgPSBlbGVtZW50LnBhcmVudE5vZGU7XG5cbiAgICAgIHdoaWxlICghY29udGFpbmVyLmhhc0F0dHJpYnV0ZSgnZGF0YS1zdGlja3ktY29udGFpbmVyJykgJiYgIWNvbnRhaW5lci5wYXJlbnROb2RlLnF1ZXJ5U2VsZWN0b3IoZWxlbWVudC5zdGlja3kuc3RpY2t5Q29udGFpbmVyKSAmJiBjb250YWluZXIgIT09IHRoaXMuYm9keSkge1xuICAgICAgICBjb250YWluZXIgPSBjb250YWluZXIucGFyZW50Tm9kZTtcbiAgICAgIH1cblxuICAgICAgcmV0dXJuIGNvbnRhaW5lcjtcbiAgICB9XG4gICAgLyoqXG4gICAgICogRnVuY3Rpb24gdGhhdCByZXR1cm5zIGVsZW1lbnQgcmVjdGFuZ2xlICYgcG9zaXRpb24gKHdpZHRoLCBoZWlnaHQsIHRvcCwgbGVmdClcbiAgICAgKiBAZnVuY3Rpb25cbiAgICAgKiBAcGFyYW0ge25vZGV9IGVsZW1lbnQgLSBFbGVtZW50IHdoaWNoIHBvc2l0aW9uICYgcmVjdGFuZ2xlIGFyZSByZXR1cm5lZFxuICAgICAqIEByZXR1cm4ge29iamVjdH1cbiAgICAgKi9cblxuICB9LCB7XG4gICAga2V5OiBcImdldFJlY3RhbmdsZVwiLFxuICAgIHZhbHVlOiBmdW5jdGlvbiBnZXRSZWN0YW5nbGUoZWxlbWVudCkge1xuICAgICAgdGhpcy5jc3MoZWxlbWVudCwge1xuICAgICAgICBwb3NpdGlvbjogJycsXG4gICAgICAgIHdpZHRoOiAnJyxcbiAgICAgICAgdG9wOiAnJyxcbiAgICAgICAgbGVmdDogJydcbiAgICAgIH0pO1xuICAgICAgdmFyIHdpZHRoID0gTWF0aC5tYXgoZWxlbWVudC5vZmZzZXRXaWR0aCwgZWxlbWVudC5jbGllbnRXaWR0aCwgZWxlbWVudC5zY3JvbGxXaWR0aCk7XG4gICAgICB2YXIgaGVpZ2h0ID0gTWF0aC5tYXgoZWxlbWVudC5vZmZzZXRIZWlnaHQsIGVsZW1lbnQuY2xpZW50SGVpZ2h0LCBlbGVtZW50LnNjcm9sbEhlaWdodCk7XG4gICAgICB2YXIgdG9wID0gMDtcbiAgICAgIHZhciBsZWZ0ID0gMDtcblxuICAgICAgZG8ge1xuICAgICAgICB0b3AgKz0gZWxlbWVudC5vZmZzZXRUb3AgfHwgMDtcbiAgICAgICAgbGVmdCArPSBlbGVtZW50Lm9mZnNldExlZnQgfHwgMDtcbiAgICAgICAgZWxlbWVudCA9IGVsZW1lbnQub2Zmc2V0UGFyZW50O1xuICAgICAgfSB3aGlsZSAoZWxlbWVudCk7XG5cbiAgICAgIHJldHVybiB7XG4gICAgICAgIHRvcDogdG9wLFxuICAgICAgICBsZWZ0OiBsZWZ0LFxuICAgICAgICB3aWR0aDogd2lkdGgsXG4gICAgICAgIGhlaWdodDogaGVpZ2h0XG4gICAgICB9O1xuICAgIH1cbiAgICAvKipcbiAgICAgKiBGdW5jdGlvbiB0aGF0IHJldHVybnMgdmlld3BvcnQgZGltZW5zaW9uc1xuICAgICAqIEBmdW5jdGlvblxuICAgICAqIEByZXR1cm4ge29iamVjdH1cbiAgICAgKi9cblxuICB9LCB7XG4gICAga2V5OiBcImdldFZpZXdwb3J0U2l6ZVwiLFxuICAgIHZhbHVlOiBmdW5jdGlvbiBnZXRWaWV3cG9ydFNpemUoKSB7XG4gICAgICByZXR1cm4ge1xuICAgICAgICB3aWR0aDogTWF0aC5tYXgoZG9jdW1lbnQuZG9jdW1lbnRFbGVtZW50LmNsaWVudFdpZHRoLCB3aW5kb3cuaW5uZXJXaWR0aCB8fCAwKSxcbiAgICAgICAgaGVpZ2h0OiBNYXRoLm1heChkb2N1bWVudC5kb2N1bWVudEVsZW1lbnQuY2xpZW50SGVpZ2h0LCB3aW5kb3cuaW5uZXJIZWlnaHQgfHwgMClcbiAgICAgIH07XG4gICAgfVxuICAgIC8qKlxuICAgICAqIEZ1bmN0aW9uIHRoYXQgdXBkYXRlcyB3aW5kb3cgc2Nyb2xsIHBvc2l0aW9uXG4gICAgICogQGZ1bmN0aW9uXG4gICAgICogQHJldHVybiB7bnVtYmVyfVxuICAgICAqL1xuXG4gIH0sIHtcbiAgICBrZXk6IFwidXBkYXRlU2Nyb2xsVG9wUG9zaXRpb25cIixcbiAgICB2YWx1ZTogZnVuY3Rpb24gdXBkYXRlU2Nyb2xsVG9wUG9zaXRpb24oKSB7XG4gICAgICB0aGlzLnNjcm9sbFRvcCA9ICh3aW5kb3cucGFnZVlPZmZzZXQgfHwgZG9jdW1lbnQuc2Nyb2xsVG9wKSAtIChkb2N1bWVudC5jbGllbnRUb3AgfHwgMCkgfHwgMDtcbiAgICB9XG4gICAgLyoqXG4gICAgICogSGVscGVyIGZ1bmN0aW9uIGZvciBsb29wc1xuICAgICAqIEBoZWxwZXJcbiAgICAgKiBAcGFyYW0ge2FycmF5fVxuICAgICAqIEBwYXJhbSB7ZnVuY3Rpb259IGNhbGxiYWNrIC0gQ2FsbGJhY2sgZnVuY3Rpb24gKG5vIG5lZWQgZm9yIGV4cGxhbmF0aW9uKVxuICAgICAqL1xuXG4gIH0sIHtcbiAgICBrZXk6IFwiZm9yRWFjaFwiLFxuICAgIHZhbHVlOiBmdW5jdGlvbiBmb3JFYWNoKGFycmF5LCBjYWxsYmFjaykge1xuICAgICAgZm9yICh2YXIgaSA9IDAsIGxlbiA9IGFycmF5Lmxlbmd0aDsgaSA8IGxlbjsgaSsrKSB7XG4gICAgICAgIGNhbGxiYWNrKGFycmF5W2ldKTtcbiAgICAgIH1cbiAgICB9XG4gICAgLyoqXG4gICAgICogSGVscGVyIGZ1bmN0aW9uIHRvIGFkZC9yZW1vdmUgY3NzIHByb3BlcnRpZXMgZm9yIHNwZWNpZmllZCBlbGVtZW50LlxuICAgICAqIEBoZWxwZXJcbiAgICAgKiBAcGFyYW0ge25vZGV9IGVsZW1lbnQgLSBET00gZWxlbWVudFxuICAgICAqIEBwYXJhbSB7b2JqZWN0fSBwcm9wZXJ0aWVzIC0gQ1NTIHByb3BlcnRpZXMgdGhhdCB3aWxsIGJlIGFkZGVkL3JlbW92ZWQgZnJvbSBzcGVjaWZpZWQgZWxlbWVudFxuICAgICAqL1xuXG4gIH0sIHtcbiAgICBrZXk6IFwiY3NzXCIsXG4gICAgdmFsdWU6IGZ1bmN0aW9uIGNzcyhlbGVtZW50LCBwcm9wZXJ0aWVzKSB7XG4gICAgICBmb3IgKHZhciBwcm9wZXJ0eSBpbiBwcm9wZXJ0aWVzKSB7XG4gICAgICAgIGlmIChwcm9wZXJ0aWVzLmhhc093blByb3BlcnR5KHByb3BlcnR5KSkge1xuICAgICAgICAgIGVsZW1lbnQuc3R5bGVbcHJvcGVydHldID0gcHJvcGVydGllc1twcm9wZXJ0eV07XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICB9XG4gIH1dKTtcblxuICByZXR1cm4gU3RpY2t5O1xufSgpO1xuLyoqXG4gKiBFeHBvcnQgZnVuY3Rpb24gdGhhdCBzdXBwb3J0cyBBTUQsIENvbW1vbkpTIGFuZCBQbGFpbiBCcm93c2VyLlxuICovXG5cblxuKGZ1bmN0aW9uIChyb290LCBmYWN0b3J5KSB7XG4gIGlmICh0eXBlb2YgZXhwb3J0cyAhPT0gJ3VuZGVmaW5lZCcpIHtcbiAgICBtb2R1bGUuZXhwb3J0cyA9IGZhY3Rvcnk7XG4gIH0gZWxzZSBpZiAodHlwZW9mIGRlZmluZSA9PT0gJ2Z1bmN0aW9uJyAmJiBkZWZpbmUuYW1kKSB7XG4gICAgZGVmaW5lKFtdLCBmdW5jdGlvbiAoKSB7XG4gICAgICByZXR1cm4gZmFjdG9yeTtcbiAgICB9KTtcbiAgfSBlbHNlIHtcbiAgICByb290LlN0aWNreSA9IGZhY3Rvcnk7XG4gIH1cbn0pKHRoaXMsIFN0aWNreSk7Il0sIm5hbWVzIjpbXSwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///(ssr)/./node_modules/sticky-js/dist/sticky.compile.js\n");

/***/ }),

/***/ "(ssr)/./node_modules/sticky-js/index.js":
/*!*****************************************!*\
  !*** ./node_modules/sticky-js/index.js ***!
  \*****************************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

eval("\nvar Sticky = __webpack_require__(/*! ./dist/sticky.compile.js */ \"(ssr)/./node_modules/sticky-js/dist/sticky.compile.js\");\n\nmodule.exports = Sticky;\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHNzcikvLi9ub2RlX21vZHVsZXMvc3RpY2t5LWpzL2luZGV4LmpzIiwibWFwcGluZ3MiOiI7QUFDQSxhQUFhLG1CQUFPLENBQUMsdUZBQTBCOztBQUUvQyIsInNvdXJjZXMiOlsid2VicGFjazovL3N0YXJiZWxseS1uZXh0anMvLi9ub2RlX21vZHVsZXMvc3RpY2t5LWpzL2luZGV4LmpzPzRiYzYiXSwic291cmNlc0NvbnRlbnQiOlsiXG52YXIgU3RpY2t5ID0gcmVxdWlyZSgnLi9kaXN0L3N0aWNreS5jb21waWxlLmpzJyk7XG5cbm1vZHVsZS5leHBvcnRzID0gU3RpY2t5O1xuIl0sIm5hbWVzIjpbXSwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///(ssr)/./node_modules/sticky-js/index.js\n");

/***/ })

};
;